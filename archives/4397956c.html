<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="工作原理," />










<meta name="description" content="在现代的计算机系统中CPU是多核多线程的架构，理论上我们可以在同一时间同时执行多条指令。而在软件设计中为了达到这个目的就发明了许多的并发编程方案。 其中在iOS中主要存在四个并发编程方案：pthread、NSThread、GCD、NSOperation。这里借用以下这张图来描述它们各自的主要特征。可以看到pthread和NSThread实际上就是线程这个概念在iOS中的抽象，使用这两个库需要开发者">
<meta name="keywords" content="工作原理">
<meta property="og:type" content="article">
<meta property="og:title" content="iOS中的并发编程与GCD的一些认知">
<meta property="og:url" content="https://hello-david.github.io/archives/4397956c.html">
<meta property="og:site_name" content="David&#39;Blog">
<meta property="og:description" content="在现代的计算机系统中CPU是多核多线程的架构，理论上我们可以在同一时间同时执行多条指令。而在软件设计中为了达到这个目的就发明了许多的并发编程方案。 其中在iOS中主要存在四个并发编程方案：pthread、NSThread、GCD、NSOperation。这里借用以下这张图来描述它们各自的主要特征。可以看到pthread和NSThread实际上就是线程这个概念在iOS中的抽象，使用这两个库需要开发者">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://hello-david.github.io/images/15714143382691.jpg">
<meta property="og:image" content="https://hello-david.github.io/images/15719205413308.jpg">
<meta property="og:image" content="https://hello-david.github.io/images/15716251935788.jpg">
<meta property="og:image" content="https://hello-david.github.io/images/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_57fb3a88-12bc-473a-9299-d97fc2f95540.png">
<meta property="og:image" content="https://hello-david.github.io/images/15808147948711.png">
<meta property="og:updated_time" content="2020-02-04T13:02:51.314Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="iOS中的并发编程与GCD的一些认知">
<meta name="twitter:description" content="在现代的计算机系统中CPU是多核多线程的架构，理论上我们可以在同一时间同时执行多条指令。而在软件设计中为了达到这个目的就发明了许多的并发编程方案。 其中在iOS中主要存在四个并发编程方案：pthread、NSThread、GCD、NSOperation。这里借用以下这张图来描述它们各自的主要特征。可以看到pthread和NSThread实际上就是线程这个概念在iOS中的抽象，使用这两个库需要开发者">
<meta name="twitter:image" content="https://hello-david.github.io/images/15714143382691.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://hello-david.github.io/archives/4397956c.html"/>



<meta name="google-site-verification" content="xPc40P1FFnuv2Aer8rA72v2doNkgf1bEhU79GGlStmE" />


  <title>iOS中的并发编程与GCD的一些认知 | David'Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">David'Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hello-david.github.io/archives/4397956c.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="David Dai">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="David'Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">iOS中的并发编程与GCD的一些认知</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-02-04T20:59:46+08:00">
                2020-02-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/工作原理/" itemprop="url" rel="index">
                    <span itemprop="name">工作原理</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>在现代的计算机系统中CPU是多核多线程的架构，理论上我们可以在同一时间同时执行多条指令。而在软件设计中为了达到这个目的就发明了许多的并发编程方案。</p>
<p>其中在iOS中主要存在四个并发编程方案：pthread、NSThread、GCD、NSOperation。这里借用以下这张图来描述它们各自的主要特征。<br><img src="/images/15714143382691.jpg" alt=""><br>可以看到pthread和NSThread实际上就是线程这个概念在iOS中的抽象，使用这两个库需要开发者自己去管理线程的声明周期(创建，调度和销毁)，一般运用在一些简单场景下。而GCD和NSOperation则是更高级的抽象，在iOS的日常开发中经常被用到。</p>
<p>并发编程可以让我们更高效率的利用多核多芯片的计算性能，但是也带来了资源竞争的问题。在深入学习GCD之前我们先来讨论一下在iOS系统中这个问题的表现。</p>
<h1 id="并发时的资源竞争"><a href="#并发时的资源竞争" class="headerlink" title="并发时的资源竞争"></a>并发时的资源竞争</h1><p>我们知道线程在并发调用的时候是无法预估它们之间执行时序先后顺序的，当存在多个线程同时操作同一个资源的时候，这个资源的读写操作就变得不可预估了。</p>
<p>如<a href="https://objccn.io/issue-2-1/" target="_blank" rel="noopener">并发编程：API 及挑战</a>里面的例子，当存在一个整型数值17分别被两条并发线程访问，当没有对这个资源进行保护的时候，这个计数器的数值与预期不一致（计数器实际上被+2但结果仍然是18）。这个问题被称为<strong>竞态条件</strong>，要解决这个问题需要保证多线程的执行顺序，也就是使用<strong>同步工具</strong>来保证并发线程的执行顺序。<br><img src="/images/15719205413308.jpg" alt=""><br>ps: 通过一些手段保证使用多线程访问时不会触发资源竞争的变量或方法被称作<strong>线程安全</strong>的变量或方法。关于iOS系统中线程安全的框架/对象<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/ThreadSafetySummary/ThreadSafetySummary.html#//apple_ref/doc/uid/10000057i-CH12-SW1" target="_blank" rel="noopener">可以看这篇文章</a></p>
<p>根据<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/ThreadSafety/ThreadSafety.html#//apple_ref/doc/uid/10000057i-CH8-SW1" target="_blank" rel="noopener">官方文档——Synchronization</a>的指导，解决资源竞争的问题主要有以下几种同步手段：</p>
<ol>
<li><p>原子操作(Atomic Operations)：一种简单的同步形式，适用于简单的数据类型。 原子操作的优点是它们不会阻塞竞争线程。 对于简单的操作（例如增加计数器变量），这比使用锁可以带来更好的性能。</p>
</li>
<li><p>内存壁垒和易失性变量(Memory Barriers and Volatile Variables)：内存屏障是一种非阻塞同步工具，用于确保内存操作以正确的顺序发生。内存屏障的作用类似于围栏，迫使处理器在允许执行位于屏障之后的加载和存储操作之前，完成位于屏障前面的所有加载和存储操作。易失性变量将另一种类型的内存约束应用于单个变量。由于内存屏障和易失性变量都会减少编译器可执行的优化次数，因此应谨慎使用它们，并且仅在需要确保正确性的地方使用它们。</p>
</li>
<li><p>锁(Locks)：锁是最常用的同步工具之一，可以使用锁来保护代码的关键部分，锁<strong>一次只能允许一个线程访问</strong>。例如，关键代码可能操纵特定的数据结构或一次使用最多支持一个客户端的某些资源。通过在此部分周围加锁，可以排除其他线程进行可能影响代码正确性的更改。</p>
</li>
<li><p>条件(Conditions)：条件是一种信号量，同时也可以看做一种特殊的锁。当某个条件为真时，它允许线程彼此发信号。条件通常用于指示资源的可用性或确保任务以特定顺序执行。当线程测试条件时，除非该条件已经为真，否则它将阻塞。它保持阻塞状态，直到其他线程显式更改并发出条件信号为止。条件和互斥锁之间的区别在于，可以<strong>允许多个线程同时访问</strong>该条件。条件更多的表现得像一个看门人，它根据某些指定的标准让不同的线程通过这个门。</p>
</li>
<li><p>执行选择器事务(Perform Selector Routines)：Cocoa框架中可以使用<code>performSelector:onThread:withObject:waitUntilDone:</code>相关的方法来在主线程或者其他线程的Runloop中顺序执行代码。</p>
</li>
</ol>
<p>可以看到上面的手段的设计目的都是方便我们使用它们来实现<strong>同步</strong>线程操作的目的，同样的我们也可以使用信号量来实现。这些<strong>同步工具</strong>中我们最为常用的应该就是各种锁（locks)了，接下来再继续学习一下关于锁的一些问题。</p>
<h2 id="锁住资源"><a href="#锁住资源" class="headerlink" title="锁住资源"></a>锁住资源</h2><p>在iOS系统中锁的类型有以下几种：</p>
<table>
<thead>
<tr>
<th>锁的类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Mutex（互斥锁）</td>
<td>互斥锁是一种信号量，它一次只能授予对一个线程的访问权限。如果正在使用互斥锁，而另一个线程试图获取该互斥锁，则该线程将阻塞，直到该互斥锁被其原始持有者释放为止。如果多个线程竞争同一个互斥锁，则一次只能访问一个。</td>
</tr>
<tr>
<td>Recursive lock（递归锁）</td>
<td>递归锁是互斥锁的一种变体。递归锁允许单个线程在释放它之前多次获取该锁（解决了互斥锁被自己多次访问导致的死锁问题）。其他线程将保持阻塞状态，直到锁的所有者以与获取锁相同的次数释放锁。递归锁主要在递归迭代期间使用，但也可以在多个方法各自需要分别获取锁的情况下使用。</td>
</tr>
<tr>
<td>Read-write Lock（读写锁）</td>
<td>读写锁也称为共享独占锁。这种类型的锁通常用于较大规模的操作，如果经常读取受保护的数据结构并仅偶尔进行修改，则可以显着提高性能。在正常操作期间，多个读取器可以同时访问数据结构。但是，当线程要写入结构时，它将阻塞，直到所有读取器都释放锁为止，此时，它获取了锁并可以更新结构。当写入线程正在等待锁定时，新的读取器线程将阻塞，直到写入线程完成。iOS系统仅支持使用POSIX线程的读写锁。有关如何使用这些锁的更多信息，请参见<a href="https://developer.apple.com/library/archive/documentation/System/Conceptual/ManPages_iPhoneOS/man3/pthread.3.html#//apple_ref/doc/man/3/pthread" target="_blank" rel="noopener">pthread手册页</a>。</td>
</tr>
<tr>
<td>Distributed Lock（分布式锁）</td>
<td>分布式锁在进程级别提供互斥访问。 与真正的互斥锁不同，分布式锁不会阻止进程或阻止其运行。 它仅报告锁何时繁忙，并让进程决定如何进行。</td>
</tr>
<tr>
<td>Spin Lock（自旋锁）</td>
<td>自旋锁反复轮询其锁定条件，直到该条件变为true。自旋锁最常用于多处理器系统，其中锁的预期等待时间很小。在这些情况下，轮询通常比阻塞线程更有效，这需要上下文切换和线程数据结构的更新。由于它们具有轮询性质，因此系统不提供自旋锁的任何实现，但是您可以在特定情况下轻松地实现它们。有关在内核中实现自旋锁的信息，请参见<a href="https://developer.apple.com/library/archive/documentation/Darwin/Conceptual/KernelProgramming/About/About.html#//apple_ref/doc/uid/TP30000905" target="_blank" rel="noopener">《内核编程指南》</a>。</td>
</tr>
<tr>
<td>Double-checked Lock（双重检查锁）</td>
<td>双重检查锁是通过在获取锁之前测试锁定条件来减少获取锁的开销的尝试。 由于双重检查的锁可能不安全，因此系统不会为它们提供明确的支持，因此不建议使用它们。</td>
</tr>
</tbody>
</table>
<p>对于应用开发而言最最最常接触到就是互斥锁、递归锁这两种锁了，它们在API层面上又被封装为NSLock、NSRecursiveLock或者@synchronized语法了。</p>
<p>这些锁通过保证线程同步访问的方式保护了资源从而解决了资源竞争的问题，但是它并不能完美解决并发编程中的所有问题，可能还会引发几个问题：</p>
<ul>
<li>死锁（经典场景：使用互斥锁的线程加锁后又再次访问这个锁）</li>
<li>资源饥饿</li>
<li>线程优先级反转</li>
</ul>
<p>限于篇幅这里就不继续展开了可在<a href="https://objccn.io/issue-2-1/" target="_blank" rel="noopener">并发编程：API 及挑战</a>这篇文档中找到相关的例子，接下来我们从官方文档——<a href="https://developer.apple.com/documentation/dispatch?language=objc" target="_blank" rel="noopener">Dispatch</a>来好好学习一下GCD相关的话题。</p>
<h1 id="GCD中任务与调度队列"><a href="#GCD中任务与调度队列" class="headerlink" title="GCD中任务与调度队列"></a>GCD中任务与调度队列</h1><p>在文档中对于GCD(libdispatch)设计目的定义是提供系统级别的高效性能调度，通过提交工作以分派系统管理的队列，在多核硬件上同时执行代码。其中GCD通过封装<strong>调度队列</strong>和<strong>任务</strong>来隐藏更细节的线程管理、调度。</p>
<p>对于GCD这个框架我们最最最常用的就是下面这两个函数了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dispatch_sync(dispatch_queue_t  _Nonnull queue, ^(void)block)</span><br><span class="line">dispatch_async(dispatch_queue_t  _Nonnull queue, ^(void)block)</span><br></pre></td></tr></table></figure></p>
<p>这两个函数的接口含义：某个<strong>任务</strong>在某个<strong>调度队列</strong>上同步或者异步执行，而它们最终会在下面这一套流程中的<code>MainThread</code>或者<code>GCD Thread Pool</code>中被执行调度。<br><img src="/images/15716251935788.jpg" alt=""></p>
<p>任务（即代码块）可以通过GCD在<strong>串行队列</strong>或者<strong>并行队列</strong>上<strong>同步</strong>或者<strong>异步</strong>执行调度。</p>
<p>串行、并行指的是同一个队列间任务与任务之间的关系，如果任务被加入串行队列中则任务与任务之间是串行的关系，意味着必须等上一个任务出队后才能进行调度（main_queue就是一个全局的串行队列)，如果任务被加入并行队列中则任务与任务之间是并发的关系，任务可以即刻开始调度执行。</p>
<p>同步、异步指的是任务调度的方式，如果在当前上下文同步调度一个任务则意味必须等到这个任务执行完毕后当前上下文才能继续执行，反之如果在当前上下文异步调度一个任务则无需等到这个任务执行完毕就会继续执行当前上下文。</p>
<p>通过上述四种基本关系组合使用GCD框架的时候最可能遇到的问题是由于不正确的使用方式导致的逻辑死锁（同步调度的时候，比如在A队列又同步调度一个任务到A队列中）。</p>
<h2 id="任务与调度队列的执行方式"><a href="#任务与调度队列的执行方式" class="headerlink" title="任务与调度队列的执行方式"></a><a href="https://developer.apple.com/documentation/dispatch/dispatch_work_item?language=objc" target="_blank" rel="noopener">任务</a>与<a href="https://developer.apple.com/documentation/dispatch/dispatch_queue?language=objc" target="_blank" rel="noopener">调度队列</a>的执行方式</h2><p>在GCD中通过封装一个代码块(Block)来声明一个任务，并且可以控制任务的执行优先级(QOS)、执行时机与执行后回调动作，这些任务一般会放到某个调度队列(FIFO)中进行调度执行。</p>
<p>在GCD中对于任务和队列的控制粒度可以很细，大多数情况下我们可以这么使用GCD来进行并发编程：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">dispatch_sync(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    NSLog(@&quot;在主线程串行队列同步调度一个任务&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    NSLog(@&quot;在主线程串行队列异步调度一个任务&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_sync(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">    NSLog(@&quot;在全局并行队列同步调度一个任务&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">    NSLog(@&quot;在全局并行队列异步调度一个任务&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>以上四种执行方式满足我们开发过程中大部分的并发需求，以下还有几种更灵活的任务执行方式。</p>
<h2 id="直接执行任务"><a href="#直接执行任务" class="headerlink" title="直接执行任务"></a><a href="https://developer.apple.com/documentation/dispatch/1431048-dispatch_block_perform?language=objc" target="_blank" rel="noopener">直接执行任务</a></h2><p>在GCD中<a href="https://developer.apple.com/documentation/dispatch/dispatch_work_item?language=objc" target="_blank" rel="noopener">任务单元</a>是调度执行的最小单元，任务单元封装了要在调度队列或调度组内执行的工作。同时还可以将任务单元用作调度源事件，注册或取消处理程序。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 声明一个任务单元</span><br><span class="line">dispatch_block_t block = dispatch_block_create(0, ^&#123;</span><br><span class="line">    NSLog(@&quot;这是一个任务&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 取消一个任务，则任务失效，执行时将不会生效</span><br><span class="line">if (dispatch_testcancel(block) == 0) &#123;</span><br><span class="line">    dispatch_cancel(block);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 在当前上下文同步执行一个任务</span><br><span class="line">dispatch_block_perform(0, block);</span><br></pre></td></tr></table></figure></p>
<p>任务单元是工作的执行实体，而调度队列、调度组是工作的执行上下文环境，在GCD中可以选择将任务单元放到特定的调度队列、调度组中进行调度，也可以选择在当前上下文直接执行一个任务单元。</p>
<h2 id="延后执行"><a href="#延后执行" class="headerlink" title="延后执行"></a><a href="https://developer.apple.com/documentation/dispatch/1452876-dispatch_after" target="_blank" rel="noopener">延后执行</a></h2><p>GCD中提供一种延后特定时间执行任务的方式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">double delayInSeconds = 2.0;</span><br><span class="line">dispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW, (int64_t) (delayInSeconds * NSEC_PER_SEC));</span><br><span class="line">dispatch_after(popTime, dispatch_get_main_queue(), ^(void)&#123;</span><br><span class="line">    NSLog(@&quot;延后2秒执行这个任务单元&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h2 id="单次执行任务"><a href="#单次执行任务" class="headerlink" title="单次执行任务"></a><a href="https://developer.apple.com/documentation/dispatch/1447169-dispatch_once" target="_blank" rel="noopener">单次执行任务</a></h2><p>在GCD中提供一种调度方式可以让某个任务在程序运行期间有且只执行一次，通常用于实现单例模式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)shared &#123;</span><br><span class="line">    static id shared;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        shared = [[self alloc] init];</span><br><span class="line">    &#125;);</span><br><span class="line">    return shared;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是实际上如果深入使用<code>dispatch_once</code>会发现它实际上并非绝对安全的，在某些场景中是有概率出现程序崩溃的。这要深究到它的实现方式上了，内部实现上有一个<strong>CPU分支预测和预执行</strong>的机制能够优化<code>dispatch_once</code>的执行效率，但是在这段代码初始过程中如果同时有多个线程在执行它就可能出现初始化预判断错误导致的线程死锁问题。</p>
<h2 id="执行一组任务"><a href="#执行一组任务" class="headerlink" title="执行一组任务"></a><a href="https://developer.apple.com/documentation/dispatch/dispatch_group?language=objc" target="_blank" rel="noopener">执行一组任务</a></h2><p>通过任务组可以聚合一组任务并同步组上的行为。我们可以将多个任务单元附加到一个组，并计划它们在同一队列或不同队列上异步执行。当所有块完成执行后，任务组将执行其完成处理程序。当然也可以同步等待组中的所有块执行完毕。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 创建任务组</span><br><span class="line">dispatch_group_t group = dispatch_group_create();</span><br><span class="line"></span><br><span class="line">// 进入任务组</span><br><span class="line">dispatch_group_enter(group);</span><br><span class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">    // 离开任务组</span><br><span class="line">    dispatch_group_leave(group);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 进入任务组</span><br><span class="line">dispatch_group_enter(group);</span><br><span class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">    // 离开任务组</span><br><span class="line">    dispatch_group_leave(group);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 任务组中的任务全部退出后的结束动作</span><br><span class="line">dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h2 id="获取-设置队列上下文数据"><a href="#获取-设置队列上下文数据" class="headerlink" title="获取/设置队列上下文数据"></a><a href="https://developer.apple.com/documentation/dispatch/1452967-dispatch_queue_set_specific" target="_blank" rel="noopener">获取/设置队列上下文数据</a></h2><p>在GCD中可以给队列附加一个上下文指针来提供一些额外的信息。当我们在使用GCD同步执行任务的时候有可能会存在死锁现象，对于主线程我们可以使用<code>[NSThread isMainThread]</code>来判断，那么对于其他线程我们可以间接标记出它所属调度队列然后安全地避开死锁问题。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 定义一个静态常量指针并用它作为这个串行队列的标记</span><br><span class="line">static const void * kQueueSpecificKey = &amp;kQueueSpecificKey;</span><br><span class="line">dispatch_queue_t serialFetchQueue = dispatch_queue_create(&quot;com.test&quot;, DISPATCH_QUEUE_SERIAL);// 串行队列</span><br><span class="line">dispatch_queue_set_specific(serialFetchQueue, kQueueSpecificKey, (__bridge void * _Nullable)(self), NULL);</span><br><span class="line"></span><br><span class="line">// 安全地实现同步调用</span><br><span class="line">dispatch_get_specific(kQueueSpecificKey) != NULL ? block() : dispatch_sync(serialFetchQueue, block);</span><br><span class="line">// 意思是假如现在已经是当前代码上下文已经在这个调度队列中了就直接执行任务</span><br></pre></td></tr></table></figure></p>
<p>在GCD在执行任务的时候，可以通过下面这段测试代码发现上诉死锁的缘故：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t serialQueue = dispatch_queue_create(&quot;com.serial.test&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">dispatch_queue_t conQueue = dispatch_queue_create(&quot;com.con.test&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">dispatch_sync(serialQueue, ^&#123;</span><br><span class="line">    NSLog(@&quot;在com.serial.test串行队列同步执行:%@&quot;, [NSThread currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_async(serialQueue, ^&#123;</span><br><span class="line">    NSLog(@&quot;在com.serial.test串行队列异步执行:%@&quot;, [NSThread currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line">    </span><br><span class="line">dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    NSLog(@&quot;在主串行队列异步执行:%@&quot;, [NSThread currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_sync(conQueue, ^&#123;</span><br><span class="line">    NSLog(@&quot;在com.con.test同步执行:%@&quot;, [NSThread currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_async(conQueue, ^&#123;</span><br><span class="line">    NSLog(@&quot;在com.con.test异步执行:%@&quot;, [NSThread currentThread]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>得出结论：<br><img src="/images/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_57fb3a88-12bc-473a-9299-d97fc2f95540.png" alt=""></p>
<table>
<thead>
<tr>
<th>调度任务到队列中</th>
<th>调度方式</th>
<th>这个任务执行时的线程</th>
</tr>
</thead>
<tbody>
<tr>
<td>在主队列上加入一个任务到A串行队列</td>
<td>同步</td>
<td>在主线程执行，不会切换线程</td>
</tr>
<tr>
<td>在主队列上加入一个任务到A串行队列</td>
<td>异步</td>
<td>切换到新线程中执行</td>
</tr>
<tr>
<td>在主队列上加入一个任务到主队列</td>
<td>异步</td>
<td>在主线程执行，不会切换线程</td>
</tr>
<tr>
<td>在主队列上加入一个任务到B并行队列</td>
<td>同步</td>
<td>在主线程执行，不会切换线程</td>
</tr>
<tr>
<td>在主队列上加入一个任务到B并行队列</td>
<td>异步</td>
<td>切换到新线程中执行</td>
</tr>
</tbody>
</table>
<p>可以看到加入我们以<strong>同步方式</strong>调度一个队列任务的时候均是在当前上下文中执行这个任务的而不会切换线程，当且仅当通过<strong>异步方式</strong>调度一个任务到<strong>新的队列</strong>的时候才会进行线程切换。</p>
<h1 id="服务质量（QOS）"><a href="#服务质量（QOS）" class="headerlink" title="服务质量（QOS）"></a>服务质量（QOS）</h1><p>在GCD中的调度队列中的任务单元是存在<strong>执行优先级</strong>的（也就是任务的服务质量）。QOS将会对调度队列上执行的工作进行了分类。通过指定任务的质量表明任务对应用程序的重要性。在安排任务时，系统会优先处理服务级别较高的任务。</p>
<p>由于高优先级的任务单元比低优先级的任务单元执行得更快、资源更多，因此与低优先级的任务单元相比，通常需要更多的精力（执行时间分片多）。为应用执行的任务单元准确地指定适当的QoS可确保应用具有更好响应能力和资源利用效率。</p>
<p>执行优先级同样可以从两个维度上指定：任务单元的优先级和队列的优先级。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 队列优先级</span><br><span class="line">#define DISPATCH_QUEUE_PRIORITY_HIGH 2</span><br><span class="line">#define DISPATCH_QUEUE_PRIORITY_DEFAULT 0</span><br><span class="line">#define DISPATCH_QUEUE_PRIORITY_LOW (-2)</span><br><span class="line">#define DISPATCH_QUEUE_PRIORITY_BACKGROUND INT16_MIN</span><br><span class="line"></span><br><span class="line">// 任务单元的优先级</span><br><span class="line">QOS_CLASS_USER_INTERACTIVE：表示任务需要被立即执行，用来在响应事件之后更新UI，来提供好的用户体验。</span><br><span class="line">QOS_CLASS_USER_INITIATED：表示任务由UI发起异步执行。适用场景是需要及时结果同时又可以继续交互的时候。</span><br><span class="line">QOS_CLASS_DEFAULT：表示默认优先级</span><br><span class="line">QOS_CLASS_UTILITY：表示需要长时间运行的任务，伴有用户可见进度指示器。经常会用来做计算，I/O，网络，持续的数据填充等任务。</span><br><span class="line">QOS_CLASS_BACKGROUND：表示用户不会察觉的任务，使用它来处理预加载，或者不需要用户交互和对时间不敏感的任务。</span><br><span class="line">QOS_CLASS_UNSPECIFIED：表示未指明，系统根据情况进行选定QOS等级</span><br></pre></td></tr></table></figure></p>
<p>两个维度的优先级关系基本对应如下：</p>
<table>
<thead>
<tr>
<th>队列优先级</th>
<th>任务单元优先级</th>
</tr>
</thead>
<tbody>
<tr>
<td>Main Thread</td>
<td>QOS_CLASS_USER_INTERACTIVE</td>
</tr>
<tr>
<td>DISPATCH_QUEUE_PRIORITY_HIGH</td>
<td>QOS_CLASS_USER_INITIATED</td>
</tr>
<tr>
<td>DISPATCH_QUEUE_PRIORITY_DEFAULT</td>
<td>QOS_CLASS_DEFAULT</td>
</tr>
<tr>
<td>DISPATCH_QUEUE_PRIORITY_LOW</td>
<td>QOS_CLASS_UTILITY</td>
</tr>
<tr>
<td>DISPATCH_QUEUE_PRIORITY_BACKGROUND</td>
<td>QOS_CLASS_BACKGROUND</td>
</tr>
</tbody>
</table>
<p>那么问题来了，假设一个任务单元的执行优先级和队列优先级不一致系统会采用哪个优先级呢？通过下面这段测试代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0), ^&#123;</span><br><span class="line">    sleep(2);</span><br><span class="line">    NSLog(@&quot;这是一个低队列优先级的任务&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">    sleep(2);</span><br><span class="line">    NSLog(@&quot;这是一个默认队列优先级的任务&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^&#123;</span><br><span class="line">    sleep(2);</span><br><span class="line">    NSLog(@&quot;这是一个高队列优先级的任务&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_block_t highBlock = dispatch_block_create_with_qos_class(0, QOS_CLASS_USER_INTERACTIVE, 0, ^&#123;</span><br><span class="line">    sleep(2);</span><br><span class="line">    NSLog(@&quot;这是一个默认队列优先级的高优先级任务&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), highBlock);</span><br></pre></td></tr></table></figure></p>
<p>运行结果可能如下（还有其他结果）：<br><img src="/images/15808147948711.png" alt=""><br>可以知道系统最终会以两者QOS属性中高的那个值作为任务单元执行时的优先级。同时任务单元并不是严格按照优先级的顺序执行的。也就是说GCD中的QOS优先级应该是作为系统线程调度的一个参考量，在CPU时间片轮转调度时参考优先级顺序先进行调度执行，在同一时刻的任务会按照高-&gt;中-&gt;低的优先级顺序去分配资源。</p>
<h1 id="任务同步"><a href="#任务同步" class="headerlink" title="任务同步"></a>任务同步</h1><p>我们知道并发任务的执行时机是不可预测的，但在GCD中可以通过<strong>信号量</strong>或者<strong>屏障</strong>实现对并发任务的执行顺序的控制。</p>
<h2 id="Dispatch-Semaphore"><a href="#Dispatch-Semaphore" class="headerlink" title="Dispatch Semaphore"></a>Dispatch Semaphore</h2><p>调度信号量是传统计数信号量的实现。仅当需要阻塞调用线程时，调度信号才调用内核。如果调用信号量不需要阻塞，则不进行内核调用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);</span><br><span class="line">    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">    sleep(1.0);</span><br><span class="line">    NSLog(@&quot;全局队列睡眠1秒后释放一个信号量&quot;);</span><br><span class="line">    dispatch_semaphore_signal(semaphore);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">NSLog(@&quot;主队列等到信号量释放后才执行&quot;);</span><br></pre></td></tr></table></figure></p>
<h2 id="Dispatch-Barrier"><a href="#Dispatch-Barrier" class="headerlink" title="Dispatch Barrier"></a>Dispatch Barrier</h2><p>屏障是一种并发队列任务执行顺序的控制手段。在向并发调度队列添加屏障时，该队列会延迟屏障块（以及屏障之后提交的所有任务）的执行，直到所有先前提交的任务完成执行为止。在完成先前的任务后，队列将自己执行屏障块。屏障块完成后，队列将恢复其正常执行行为。这是一种针对<strong>用户自定义并发队列</strong>的同步手段，对串行队列和全局队列是无效的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t conQueue = dispatch_queue_create(&quot;com.con.test&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">dispatch_async(conQueue, ^&#123;</span><br><span class="line">    sleep(1);</span><br><span class="line">    NSLog(@&quot;这个一个com.con.test并发任务&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_barrier_async(conQueue, ^&#123;</span><br><span class="line">    NSLog(@&quot;这是一个包含屏障的任务，会等到这个com.con.test并发队列先前的任务调度完成再执行&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_async(conQueue, ^&#123;</span><br><span class="line">    NSLog(@&quot;这个一个com.con.test屏障后的并发任务&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h1 id="系统事件监控"><a href="#系统事件监控" class="headerlink" title="系统事件监控"></a>系统事件监控</h1><p>GCD除了上述的并发编程的能力，它还拥有系统事件监控的能力。具体的它可以接收以下几种事件输入源对象：</p>
<ul>
<li>Dispatch Source：协调特定低级系统事件（例如文件系统事件，计时器和UNIX信号）的处理的对象。</li>
<li>Dispatch I/O：使用基于流或随机访问的语义管理文件描述符上的操作的对象。</li>
<li>Dispatch Data：一个用于管理基于内存的数据缓冲区，并将其公开为连续的内存块对象。</li>
</ul>
<h2 id="Dispatch-Source"><a href="#Dispatch-Source" class="headerlink" title="Dispatch Source"></a>Dispatch Source</h2><p>Dispatch Source用于监听系统的底层对象。比如文件描述符、Mach端口、信号量等。主要处理的事件如下表：</p>
<table>
<thead>
<tr>
<th>触发源</th>
<th>代表触发动作</th>
</tr>
</thead>
<tbody>
<tr>
<td>DISPATCH_SOURCE_TYPE_DATA_ADD</td>
<td>数据增加</td>
</tr>
<tr>
<td>DISPATCH_SOURCE_TYPE_DATA_OR</td>
<td>数据OR</td>
</tr>
<tr>
<td>DISPATCH_SOURCE_TYPE_MACH_SEND</td>
<td>Mach端口发送</td>
</tr>
<tr>
<td>DISPATCH_SOURCE_TYPE_MACH_RECV</td>
<td>Mach端口接收</td>
</tr>
<tr>
<td>DISPATCH_SOURCE_TYPE_MEMORYPRESSURE</td>
<td>内存压力</td>
</tr>
<tr>
<td>DISPATCH_SOURCE_TYPE_PROC</td>
<td>进程事件</td>
</tr>
<tr>
<td>DISPATCH_SOURCE_TYPE_SIGNAL</td>
<td>信号</td>
</tr>
<tr>
<td>DISPATCH_SOURCE_TYPE_VNODE</td>
<td>文件系统对象更改</td>
</tr>
<tr>
<td>DISPATCH_SOURCE_TYPE_WRITE</td>
<td>文件系统对象写</td>
</tr>
<tr>
<td>DISPATCH_SOURCE_TYPE_READ</td>
<td>文件系统对象读</td>
</tr>
<tr>
<td>DISPATCH_SOURCE_TYPE_TIMER</td>
<td>定时器</td>
</tr>
</tbody>
</table>
<p>其中我们主要通过这几个方法来实现事件监听：</p>
<ul>
<li>dispatch_source_create：创建dispatch source，创建后会处于挂起状态进行事件接收，需要设置事件处理handler进行事件处理。</li>
<li>dispatch_source_set_event_handler：设置事件处理handler</li>
<li>dispatch_source_set_cancel_handler：事件取消handler，就是在dispatch source释放前做些清理的事。</li>
<li>dispatch_resume：唤醒事件监听。</li>
<li>dispatch_source_cancel：关闭dispatch source，设置的事件处理handler不会被执行，已经执行的事件handler不会取消。</li>
</ul>
<h3 id="应用——基于GCD的定时器"><a href="#应用——基于GCD的定时器" class="headerlink" title="应用——基于GCD的定时器"></a>应用——基于GCD的定时器</h3><p>我们知道NSTimer是通过Runloop实现的，而之前学习到由于Runloop中会受到其他代码执行效率以及模式切换的影响，所以NSTimer是不准确的。在GCD中可以监听系统级的定时器触发源让我们实现精准地定时事件触发。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_attr_t attr = dispatch_queue_attr_make_with_qos_class(DISPATCH_QUEUE_SERIAL, QOS_CLASS_DEFAULT, 0);</span><br><span class="line">self.backgroundTaskRecordQueue = dispatch_queue_create(&quot;com.test.timer&quot;, attr);</span><br><span class="line"></span><br><span class="line">self.backgroundTaskRecordTimer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, self.backgroundTaskRecordQueue);</span><br><span class="line">dispatch_source_set_timer(self.backgroundTaskRecordTimer, DISPATCH_TIME_NOW, 3.0f * NSEC_PER_SEC, 0);</span><br><span class="line">dispatch_source_set_event_handler(self.backgroundTaskRecordTimer, ^&#123;</span><br><span class="line">    NSLog(@&quot;Time Triggle&quot;)</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_resume(self.backgroundTaskRecordTimer);</span><br></pre></td></tr></table></figure></p>
<h2 id="Dispatch-I-O-与-Dispatch-Data"><a href="#Dispatch-I-O-与-Dispatch-Data" class="headerlink" title="Dispatch I/O 与 Dispatch Data"></a>Dispatch I/O 与 Dispatch Data</h2><p>此外对于GCD提供的输入输出控制可参考<a href="https://objccn.io/issue-2-3/" target="_blank" rel="noopener">底层并发 API</a>这篇文章里的描述，我们可以通过这项能力提高IO的使用效率。</p>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>一套学习下来，再次总结GCD这个框架是苹果开发的高效利用多核性能的并发编程库。它极力地向开发者隐藏线程管理的实现细节（在底层自己维护线程池），通过抽象<strong>调度队列</strong>和<strong>任务</strong>这两个概念来方便开发者进行并发编程，同时这套框架还提供系统事件监听机制的能力。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://developer.apple.com/videos/play/wwdc2015/718/" target="_blank" rel="noopener">wwdc2015-718</a><br><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/Introduction/Introduction.html#//apple_ref/doc/uid/10000057i-CH1-SW1" target="_blank" rel="noopener">Threading Programming Guide</a><br><a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008091-CH1-SW1" target="_blank" rel="noopener">Concurrency Programming Guide</a><br><a href="https://objccn.io/issue-2-1/" target="_blank" rel="noopener">并发编程：API 及挑战</a><br><a href="https://objccn.io/issue-2-3/" target="_blank" rel="noopener">底层并发 API</a><br><a href="https://renchao0711.github.io/2017/07/17/GCD%E6%95%B4%E7%90%86/" target="_blank" rel="noopener">GCD整理</a><br><a href="https://opensource.apple.com/tarballs/libdispatch/" target="_blank" rel="noopener">GCD源码</a><br><a href="https://juejin.im/post/5b629d52f265da0f6f1abb3f" target="_blank" rel="noopener">GCD学习参考</a></p>

      
    </div>
    
    
    
    <div>
      
        
<div class="my_post_copyright">
  <script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>
  <!-- JS库 sweetalert 可修改路径 -->
  <script type="text/javascript" src="http://jslibs.wuxubj.cn/sweetalert_mini/jquery-1.7.1.min.js"></script>
  <script src="http://jslibs.wuxubj.cn/sweetalert_mini/sweetalert.min.js"></script>
  <link rel="stylesheet" type="text/css" href="http://jslibs.wuxubj.cn/sweetalert_mini/sweetalert.mini.css">
  <p><span>本文标题:</span><a href="/archives/4397956c.html">iOS中的并发编程与GCD的一些认知</a></p>
  <p><span>文章作者:</span><a href="/" title="访问 David Dai 的个人博客">David Dai</a></p>
  <p><span>发布时间:</span>2020年02月04日 - 20:02</p>
  <p><span>最后更新:</span>2020年02月04日 - 21:02</p>
  <p><span>原始链接:</span><a href="/archives/4397956c.html" title="iOS中的并发编程与GCD的一些认知">https://hello-david.github.io/archives/4397956c.html</a>
    <span class="copy-path"  title="点击复制文章链接"><i class="fa fa-clipboard" data-clipboard-text="https://hello-david.github.io/archives/4397956c.html"  aria-label="复制成功！"></i></span>
  </p>
  <p><span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)">署名-非商业性使用-禁止演绎 4.0 国际</a> 转载请保留原文链接及作者。</p>  
</div>
<script> 
    var clipboard = new Clipboard('.fa-clipboard');
    clipboard.on('success', $(function(){
      $(".fa-clipboard").click(function(){
        swal({   
          title: "",   
          text: '复制成功',   
          html: false,
          timer: 500,   
          showConfirmButton: false
        });
      });
    }));  
</script>

      
    </div>

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/工作原理/" rel="tag"># 工作原理</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/archives/61787736.html" rel="next" title="免99刀开发iOS应用——解锁App的高级能力">
                <i class="fa fa-chevron-left"></i> 免99刀开发iOS应用——解锁App的高级能力
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">David Dai</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">27</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#并发时的资源竞争"><span class="nav-number">1.</span> <span class="nav-text">并发时的资源竞争</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#锁住资源"><span class="nav-number">1.1.</span> <span class="nav-text">锁住资源</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#GCD中任务与调度队列"><span class="nav-number">2.</span> <span class="nav-text">GCD中任务与调度队列</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#任务与调度队列的执行方式"><span class="nav-number">2.1.</span> <span class="nav-text">任务与调度队列的执行方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#直接执行任务"><span class="nav-number">2.2.</span> <span class="nav-text">直接执行任务</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#延后执行"><span class="nav-number">2.3.</span> <span class="nav-text">延后执行</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#单次执行任务"><span class="nav-number">2.4.</span> <span class="nav-text">单次执行任务</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#执行一组任务"><span class="nav-number">2.5.</span> <span class="nav-text">执行一组任务</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#获取-设置队列上下文数据"><span class="nav-number">2.6.</span> <span class="nav-text">获取/设置队列上下文数据</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#服务质量（QOS）"><span class="nav-number">3.</span> <span class="nav-text">服务质量（QOS）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#任务同步"><span class="nav-number">4.</span> <span class="nav-text">任务同步</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Dispatch-Semaphore"><span class="nav-number">4.1.</span> <span class="nav-text">Dispatch Semaphore</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Dispatch-Barrier"><span class="nav-number">4.2.</span> <span class="nav-text">Dispatch Barrier</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#系统事件监控"><span class="nav-number">5.</span> <span class="nav-text">系统事件监控</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Dispatch-Source"><span class="nav-number">5.1.</span> <span class="nav-text">Dispatch Source</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#应用——基于GCD的定时器"><span class="nav-number">5.1.1.</span> <span class="nav-text">应用——基于GCD的定时器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Dispatch-I-O-与-Dispatch-Data"><span class="nav-number">5.2.</span> <span class="nav-text">Dispatch I/O 与 Dispatch Data</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#最后"><span class="nav-number">6.</span> <span class="nav-text">最后</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#参考"><span class="nav-number">7.</span> <span class="nav-text">参考</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">David Dai</span>

  
</div>

<!--

  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>



-->
        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
